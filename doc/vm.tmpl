            +--------------------------+
            |          OS 211          |
            |  TASK 3: VIRTUAL MEMORY  |
            |      DESIGN DOCUMENT     |
            +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Andrei Bara <ab6610@imperial.ac.uk>
Rory Allford <rda10@imperial.ac.uk>
Alina Boghiu <ab---@imperial.ac.uk>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* struct thread changed */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
added  struct list supp_list;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/* Supplementary page table information and structs*/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
enum supp_flag
{
	RAM = 0U,
	SWAP = 1U,
	FILE = 2U,
	EXE = 3U,
	WRITABLE = 32U
};


struct supp_entry
{
	/* store information in this 32 bit number
	 * in a bitwise fashion; 
	 */
	uint32_t info_arena;

	//pointer to where the page is now (i.e. swap, disk, etc.)
	void *table_ptr;

	/*use this in conjunction with a list
	 *of supplemental table entries
	 */
	struct list_elem supp_elem;
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DESCRIPTION:

enum supp_flag stores values for the flags that are going to be set in
the supp_entry information pool (info_arena).

supp_entry is the structure used in the supplemental page table to acquire
all the necessary information.
The structure of the info_arena is as follows:

Bits 0-1: used to store the current state of the page (i.e. in RAM, SWAP, FILE
or EXE)

Bits 2-3: used to store the initial state of the page(i.e. if created from RAM
as a stack page most likely, copied from FILE or from EXE).

Bit 4: the sticky bit (if set then the page should not be evicted from the frame)
Bit 5: the writable bit (the page is writable so if the page has been written then
evict it to SWAP or FILE)

table_ptr is a pointer to the auxiliary data structures used by either the swap_table
or the frame_table;

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


/*Frame table information and structs, locks and lists */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern struct frame_info *frame_table;
extern struct lock frame_lock;
extern struct list frame_list;

struct frame_info
{

    struct supp_entry *s_entry;
    uint32_t *pd;
    uint32_t *upage;

    struct list_elem frame_elem;
};

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DESCRIPTION:
This structure will be used to store information about each user frame so
that we can implement paging properly. 
The frame table is actually an array of frame_info structs that is being allocated
whenever the OS starts.

frame_list is being used for storing the FIFO information required for the
second chance eviction algorithm.

frame_lock is being used to ensure overall synchronization with palloc_get_page
and palloc_free_page, etc. (i.e. with the whole paging/swapping algorithm)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


/* Swap struct */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/* A swapfile on a block device */
struct swapfile
  {
    struct bitmap * page_map;         /* Bitmap of allocated pages in swap */
    
    struct block * device;            /* Block device swapfile is stored on */
    
    swap_index_t size;                    /* page slot numbers 0 <= x < size */
  };
  
  
struct swapfile *swap_table = NULL;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DESCRIPTION:
swapfile a.k.a swap_table will keep information about the swap partition.
It is the structure that is being used when swapping pages in and out.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

Initially the frame table (which is an arrray) is allocated during system 
boot-up and has the exact size of the number of user pages that are going to be 
available.

The frame table is a one to one mapping between kernel addresses and frame
table indexes. Thus when we want to locate frame information for a certain
page we get the kernel address of that page (using pagedir_get_page)
and then map it to a frame index (see the macros defined in the code).
This will allow for constant time operations whenever we need to access a frame 
table entry. The frame entry will contain a pointer to a supplemental page
table entry (also for the same reason of access speed).

Obviously this only makes sense in the context of a page being in a frame.
When a page is not in the frame we use the unused 31 bits of a page table entry
to return a pointer to a supplemental page table entry (see the code for a more
clear understanding on how this operation works, i.e. pagedir_set_ptr). 
The rest of the information about the page itself can then be retrieved from here. 

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We avoid alias problems between kernel and user virtual addresses by only using
user addresses when operating on a page (i.e. whenever reading to a page or 
from a page during eviction processes and in the page fault handler). Also
as we are using only user virtual addresses to get the supplemental entries
or information about the dirty and accessed bits, even if the flags in the PTE 
entries for the kernel virtual addresses will become incosistent with their
aliased user addresses this would not be a problem as those flags will never
be used in our algorithm (i.e. when actually checking the flags).

Therefore a real alias problem might arise only when dealing with shared pages
between user processes or shared file mappings. 

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

The only places when a user process might require a frame have been carefully
identified in the code (i.e. these places are usually, in the presence of 
pagedir_get_page and whenever palloc_get_page(PAL_USER) is being called:
installation of the first stack page, and the page fault handler; also
access to the frame table is required usually when calling palloc_free_page: 
clearing the page directory or swapping out or just removing unsucessfully
setup pages).

Therefore to ensure race conditions are avoided on the frame table we lock
the frame table whenever an allocation or deallocation of a user page takes
place (using frame_lock). This not only ensures the sanity of the frame table 
but also keeps it consistent with the process page table, 
the user pool and swap table/partition.

Furthermore concurent accesses when acquiring a frame will most likely result
in the eviction of a page belonging to another process. In such case we
ensured that the other process, if it's doing an operation on the frame table needs
to acquire a lock prior to that so that its operation and page table is kept in
a safe state. 

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

As a whole principle we used the already existing page table to keep the mappings
and also the additional information required for a page. We have managed to do
this by modyfing the PTE entry so that when the present bit is set to 0 we use
the remaining 31 bits as a pointer to the supplemental entry (this will always
exist by the time the pointer is being set in the PTE). The reasons for why this
works is explained in more detail in the code, but a as a general idea a malloced
object will always have an address above 0xc000000000 thus we can always assume
that the most significant bit of the pointer address will be 1 (i.e. this
will leave us enough space in the PTE to set/reset the present bit).

Whenever a page installed in a frame the frame table entry will contain a 
pointer to the supplemental entry the PTE was previously pointing to, thus
guaranteeing that we never lose track of the supplemental entries when paging.

A supplemental page table entry contains an info_arena which (doing bitwise
operations) will in turn contain information about the current state of the page
(i.e. in SWAP, FILE, RAM, etc.) the initial type/state, if the page is writable,
or if the page is supposed to be pinned in the frame. An important aspect is
the table_ptr pointer in the supp entry which will point to some other auxiliary
data structures as follows:
    1.  For the EXE init state the pointer will point to a mmap_entry (which
    has been hacked so that its  file_ptr will hold the starting point to read
    from the file and the page_offset field will hold the number of bytes to
    be read from file.
    2. For FILE init state this will point to a mmap_entry created whenever
    memory mapping a file
    3. For RAM this will always point to NULL as its current state will at some
    future point change to SWAP at which point the entry will point to the
    swap_table.
    4. SWAP will never be an initial state.
    
Also the supplemental table entries are being kept in a list in the thread 
struct so that they can be accessed whenever the thread dies and frees up its
resources

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.


/* Swap struct */
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/* A swapfile on a block device */
struct swapfile
  {
    struct bitmap * page_map;         /* Bitmap of allocated pages in swap */
    
    struct block * device;            /* Block device swapfile is stored on */
    
    swap_index_t size;                    /* page slot numbers 0 <= x < size */
  };
  
  
struct swapfile *swap_table = NULL;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DESCRIPTION:
swapfile a.k.a swap_table will keep information about the swap partition.
It is the structure that is being used when swapping pages in and out.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining tasks?

>> Any other comments?
